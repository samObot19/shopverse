package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.68

import (
	"context"
	"fmt"
	"log"
	"time"
	"strconv"

	"github.com/google/uuid"
	"github.com/samObot19/shopverse/api-gate-way/graph/model"
	productclient "github.com/samObot19/shopverse/api-gate-way/product-client"
	"github.com/samObot19/shopverse/api-gate-way/order-client/proto/pb"
)

// AddUser is the resolver for the addUser mutation.
func (r *mutationResolver) AddUser(ctx context.Context, name string, email string, password string) (*model.User, error) {
	resp, err := r.Resolver.UserClient.AddUser(ctx, name, email, password)
	if err != nil {
		log.Printf("Error adding user: %v", err)
		return nil, fmt.Errorf("failed to add user: %w", err)
	}
	return &model.User{
		ID:       &resp.User.Id,
		Name:     &resp.User.Name,
		Email:    &resp.User.Email,
		Password: &resp.User.Password,
		Role:     &resp.User.Role,
	}, nil
}

// PromoteUser is the resolver for the promoteUser mutation.
func (r *mutationResolver) PromoteUser(ctx context.Context, username string) (*string, error) {
	resp, err := r.Resolver.UserClient.PromoteUser(ctx, username)
	if err != nil {
		log.Printf("Error promoting user: %v", err)
		return nil, fmt.Errorf("failed to promote user: %w", err)
	}
	message := resp.Message
	return &message, nil
}

// CreateProduct is the resolver for the createProduct mutation.
func (r *mutationResolver) CreateProduct(ctx context.Context, input model.ProductInput) (string, error) {
	product := &model.Product{
		ID:          uuid.New().String(), // Generate a unique ID
		Title:       input.Title,
		Description: input.Description,
		Price:       input.Price,
		Stock:       input.Stock,
		Category:    input.Category,
		Attributes: &model.ProductAttributes{
			Color: input.Attributes.Color,
			Size:  input.Attributes.Size,
		},
		Images:    input.Images,
		Ratings:   input.Ratings,
		CreatedAt: time.Now().Format(time.RFC3339), // Set current timestamp
	}
	err := r.Resolver.ProductClient.CreateProduct(ctx, productclient.ToProtoProduct(product))
	if err != nil {
		log.Printf("Error creating product: %v", err)
		return "", fmt.Errorf("failed to create product: %w", err)
	}
	return "Product created successfully", nil
}

// UpdateProduct is the resolver for the updateProduct mutation.
func (r *mutationResolver) UpdateProduct(ctx context.Context, id string, input model.ProductInput) (string, error) {
	product := &model.Product{
		Title:       input.Title,
		Description: input.Description,
		Price:       input.Price,
		Stock:       input.Stock,
		Category:    input.Category,
		Attributes: &model.ProductAttributes{
			Color: input.Attributes.Color,
			Size:  input.Attributes.Size,
		},
		Images:  input.Images,
		Ratings: input.Ratings,
	}
	err := r.Resolver.ProductClient.UpdateProduct(ctx, id, productclient.ToProtoProduct(product))
	if err != nil {
		log.Printf("Error updating product: %v", err)
		return "", fmt.Errorf("failed to update product: %w", err)
	}
	return "Product updated successfully", nil
}

// DeleteProduct is the resolver for the deleteProduct mutation.
func (r *mutationResolver) DeleteProduct(ctx context.Context, id string) (string, error) {
	err := r.Resolver.ProductClient.DeleteProduct(ctx, id)
	if err != nil {
		log.Printf("Error deleting product: %v", err)
		return "", fmt.Errorf("failed to delete product: %w", err)
	}
	return "Product deleted successfully", nil
}

// UpdateStock is the resolver for the updateStock mutation.
func (r *mutationResolver) UpdateStock(ctx context.Context, id string, quantity int32) (string, error) {
	err := r.Resolver.ProductClient.UpdateStock(ctx, id, quantity)
	if err != nil {
		log.Printf("Error updating stock: %v", err)
		return "", fmt.Errorf("failed to update stock: %w", err)
	}
	return "Stock updated successfully", nil
}

// CreateOrder is the resolver for the createOrder mutation.
func (r *mutationResolver) CreateOrder(ctx context.Context, input model.OrderInput) (string, error) {
	orderItems := []*pb.OrderItem{}
	for _, item := range input.Items {
		orderItems = append(orderItems, &pb.OrderItem{
			ProductId: func() uint32 {
				id, err := strconv.ParseUint(item.ProductID, 10, 32)
				if err != nil {
					log.Printf("Error parsing ProductID to uint32: %v", err)
					return 0
				}
				return uint32(id)
			}(),
			ProductPrice: float32(item.ProductPrice),
			Quantity:     uint32(item.Quantity),
			TotalPrice:   float32(item.TotalPrice),
		})
	}

	userIDUint, err := strconv.ParseUint(input.UserID, 10, 32)
	if err != nil {
		log.Printf("Error parsing UserID to uint32: %v", err)
		return "", fmt.Errorf("invalid UserID format: %w", err)
	}

	protoOrderItems := []*pb.OrderItem{}
	for _, item := range orderItems {
		protoOrderItems = append(protoOrderItems, &pb.OrderItem{
			ProductId:    item.ProductId,
			ProductPrice: float32(item.ProductPrice),
			Quantity:     uint32(item.Quantity),
			TotalPrice:   item.TotalPrice,
		})
	}

	resp, err := r.Resolver.OrderClient.CreateOrder(ctx, uint32(userIDUint), protoOrderItems, input.ShippingAddress, input.BillingAddress)
	if err != nil {
		log.Printf("Error creating order: %v", err)
		return "", fmt.Errorf("failed to create order: %w", err)
	}
	return fmt.Sprintf("Order created successfully with ID: %d", resp.OrderId), nil
}

// UpdateOrderStatus is the resolver for the updateOrderStatus mutation.
func (r *mutationResolver) UpdateOrderStatus(ctx context.Context, orderID string, status string) (string, error) {
	orderIDUint, err := strconv.ParseUint(orderID, 10, 32)
	if err != nil {
		log.Printf("Error parsing orderID to uint32: %v", err)
		return "", fmt.Errorf("invalid orderID format: %w", err)
	}
	resp, err := r.Resolver.OrderClient.UpdateOrderStatus(ctx, uint32(orderIDUint), status)
	if err != nil {
		log.Printf("Error updating order status: %v", err)
		return "", fmt.Errorf("failed to update order status: %w", err)
	}
	return resp.Message, nil
}

// UpdatePaymentStatus is the resolver for the updatePaymentStatus mutation.
func (r *mutationResolver) UpdatePaymentStatus(ctx context.Context, orderID string, paymentStatus string) (string, error) {
	orderIDUint, err := strconv.ParseUint(orderID, 10, 32)
	if err != nil {
		log.Printf("Error parsing orderID to uint32: %v", err)
		return "", fmt.Errorf("invalid orderID format: %w", err)
	}
	resp, err := r.Resolver.OrderClient.UpdatePaymentStatus(ctx, uint32(orderIDUint), paymentStatus)
	if err != nil {
		log.Printf("Error updating payment status: %v", err)
		return "", fmt.Errorf("failed to update payment status: %w", err)
	}
	return resp.Message, nil
}

// DeleteOrder is the resolver for the deleteOrder mutation.
func (r *mutationResolver) DeleteOrder(ctx context.Context, orderID string) (string, error) {
	orderIDUint, err := strconv.ParseUint(orderID, 10, 32)
	if err != nil {
		log.Printf("Error parsing orderID to uint32: %v", err)
		return "", fmt.Errorf("invalid orderID format: %w", err)
	}
	resp, err := r.Resolver.OrderClient.DeleteOrder(ctx, uint32(orderIDUint))
	if err != nil {
		log.Printf("Error deleting order: %v", err)
		return "", fmt.Errorf("failed to delete order: %w", err)
	}
	return resp.Message, nil
}

// GetUser is the resolver for the getUser query.
func (r *queryResolver) GetUser(ctx context.Context, username string) (*model.User, error) {
	resp, err := r.Resolver.UserClient.GetUser(ctx, username)
	if err != nil {
		log.Printf("Error fetching user: %v", err)
		return nil, fmt.Errorf("failed to fetch user: %w", err)
	}
	return &model.User{
		ID:       &resp.User.Id,
		Name:     &resp.User.Name,
		Email:    &resp.User.Email,
		Password: &resp.User.Password,
		Role:     &resp.User.Role,
	}, nil
}

// GetAllUsers is the resolver for the getAllUsers query.
func (r *queryResolver) GetAllUsers(ctx context.Context) ([]*model.User, error) {
	resp, err := r.Resolver.UserClient.GetAllUsers(ctx)
	if err != nil {
		log.Printf("Error fetching all users: %v", err)
		return nil, fmt.Errorf("failed to fetch all users: %w", err)
	}
	var users []*model.User
	for _, u := range resp.Users {
		users = append(users, &model.User{
			ID:       &u.Id,
			Name:     &u.Name,
			Email:    &u.Email,
			Password: &u.Password,
			Role:     &u.Role,
		})
	}
	return users, nil
}

// GetProductByID is the resolver for the getProductByID query.
func (r *queryResolver) GetProductByID(ctx context.Context, id string) (*model.Product, error) {
	protoProduct, err := r.Resolver.ProductClient.GetProductByID(ctx, id)
	if err != nil {
		log.Printf("Error fetching product by ID: %v", err)
		return nil, fmt.Errorf("failed to fetch product: %w", err)
	}
	return productclient.FromProtoProduct(protoProduct), nil
}

// GetAllProducts is the resolver for the getAllProducts query.
func (r *queryResolver) GetAllProducts(ctx context.Context, filters []*model.FilterInput) ([]*model.Product, error) {
	filterMap := make(map[string]string)
	for _, filter := range filters {
		filterMap[filter.Key] = filter.Value
	}
	protoProducts, err := r.Resolver.ProductClient.GetAllProducts(ctx, filterMap)
	if err != nil {
		log.Printf("Error fetching all products: %v", err)
		return nil, fmt.Errorf("failed to fetch all products: %w", err)
	}
	var products []*model.Product
	for _, protoProduct := range protoProducts {
		products = append(products, productclient.FromProtoProduct(protoProduct))
	}
	return products, nil
}

// GetProductsByCategory is the resolver for the getProductsByCategory query.
func (r *queryResolver) GetProductsByCategory(ctx context.Context, category string) ([]*model.Product, error) {
	protoProducts, err := r.Resolver.ProductClient.GetProductsByCategory(ctx, category)
	if err != nil {
		log.Printf("Error fetching products by category: %v", err)
		return nil, fmt.Errorf("failed to fetch products by category: %w", err)
	}
	var products []*model.Product
	for _, protoProduct := range protoProducts {
		products = append(products, productclient.FromProtoProduct(protoProduct))
	}
	return products, nil
}

// SearchProducts is the resolver for the searchProducts query.
func (r *queryResolver) SearchProducts(ctx context.Context, query string) ([]*model.Product, error) {
	protoProducts, err := r.Resolver.ProductClient.SearchProducts(ctx, query)
	if err != nil {
		log.Printf("Error searching products: %v", err)
		return nil, fmt.Errorf("failed to search products: %w", err)
	}
	var products []*model.Product
	for _, protoProduct := range protoProducts {
		products = append(products, productclient.FromProtoProduct(protoProduct))
	}
	return products, nil
}

// GetOrderByID is the resolver for the getOrderByID query.
func (r *queryResolver) GetOrderByID(ctx context.Context, orderID string) (*model.Order, error) {
	orderIDUint, err := strconv.ParseUint(orderID, 10, 32)
	if err != nil {
		log.Printf("Error parsing orderID to uint32: %v", err)
		return nil, fmt.Errorf("invalid orderID format: %w", err)
	}
	order, err := r.Resolver.OrderClient.GetOrderByID(ctx, uint32(orderIDUint))
	if err != nil {
		log.Printf("Error fetching order by ID: %v", err)
		return nil, fmt.Errorf("failed to fetch order: %w", err)
	}

	orderItems := []*model.OrderItem{}
	for _, item := range order.Items {
		orderItems = append(orderItems, &model.OrderItem{
			ID:          fmt.Sprintf("%d", item.Id),
			ProductID:   fmt.Sprintf("%d", item.ProductId),
			ProductPrice: float64(item.ProductPrice),
			Quantity:    int32(item.Quantity),
			TotalPrice:  float64(item.TotalPrice),
		})
	}

	return &model.Order{
		ID:             fmt.Sprintf("%d", order.Id),
		UserID:         fmt.Sprintf("%d", order.UserId),
		OrderStatus:    order.OrderStatus,
		PaymentStatus:  order.PaymentStatus,
		TotalAmount:    float64(order.TotalAmount),
		ShippingAddress: order.ShippingAddress,
		BillingAddress: order.BillingAddress,
		CreatedAt:      order.CreatedAt,
		UpdatedAt:      order.UpdatedAt,
		Items:          orderItems,
	}, nil
}

// GetAllOrders is the resolver for the getAllOrders query.
func (r *queryResolver) GetAllOrders(ctx context.Context, userID string) ([]*model.Order, error) {
	userIDUint, err := strconv.ParseUint(userID, 10, 32)
	if err != nil {
		log.Printf("Error parsing userID to uint32: %v", err)
		return nil, fmt.Errorf("invalid userID format: %w", err)
	}
	orders, err := r.Resolver.OrderClient.GetAllOrders(ctx, uint32(userIDUint))
	if err != nil {
		log.Printf("Error fetching all orders: %v", err)
		return nil, fmt.Errorf("failed to fetch all orders: %w", err)
	}

	var result []*model.Order
	for _, order := range orders {
		orderItems := []*model.OrderItem{}
		for _, item := range order.Items {
			orderItems = append(orderItems, &model.OrderItem{
				ID:          fmt.Sprintf("%d", item.Id),
				ProductID:   fmt.Sprintf("%d", item.ProductId),
				ProductPrice: float64(item.ProductPrice),
				Quantity:    int32(item.Quantity),
				TotalPrice:  float64(item.TotalPrice),
			})
		}

		result = append(result, &model.Order{
			ID:             fmt.Sprintf("%d", order.Id),
			UserID:         fmt.Sprintf("%d", order.UserId),
			OrderStatus:    order.OrderStatus,
			PaymentStatus:  order.PaymentStatus,
			TotalAmount:    float64(order.TotalAmount),
			ShippingAddress: order.ShippingAddress,
			BillingAddress: order.BillingAddress,
			CreatedAt:      order.CreatedAt,
			UpdatedAt:      order.UpdatedAt,
			Items:          orderItems,
		})
	}
	return result, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

