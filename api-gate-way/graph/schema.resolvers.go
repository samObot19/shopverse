package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.68

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/google/uuid"
	"github.com/samObot19/shopverse/api-gate-way/graph/model"
	productclient "github.com/samObot19/shopverse/api-gate-way/product-client"
)

// AddUser is the resolver for the addUser mutation.
func (r *mutationResolver) AddUser(ctx context.Context, name string, email string, password string) (*model.User, error) {
	resp, err := r.Resolver.UserClient.AddUser(ctx, name, email, password)
	if err != nil {
		log.Printf("Error adding user: %v", err)
		return nil, fmt.Errorf("failed to add user: %w", err)
	}
	return &model.User{
		ID:       &resp.User.Id,
		Name:     &resp.User.Name,
		Email:    &resp.User.Email,
		Password: &resp.User.Password,
		Role:     &resp.User.Role,
	}, nil
}

// PromoteUser is the resolver for the promoteUser mutation.
func (r *mutationResolver) PromoteUser(ctx context.Context, username string) (*string, error) {
	resp, err := r.Resolver.UserClient.PromoteUser(ctx, username)
	if err != nil {
		log.Printf("Error promoting user: %v", err)
		return nil, fmt.Errorf("failed to promote user: %w", err)
	}
	message := resp.Message
	return &message, nil
}

// CreateProduct is the resolver for the createProduct mutation.
func (r *mutationResolver) CreateProduct(ctx context.Context, input model.ProductInput) (string, error) {
	product := &model.Product{
		ID:          uuid.New().String(), // Generate a unique ID
		Title:       input.Title,
		Description: input.Description,
		Price:       input.Price,
		Stock:       input.Stock,
		Category:    input.Category,
		Attributes: &model.ProductAttributes{
			Color: input.Attributes.Color,
			Size:  input.Attributes.Size,
		},
		Images:    input.Images,
		Ratings:   input.Ratings,
		CreatedAt: time.Now().Format(time.RFC3339), // Set current timestamp
	}
	err := r.Resolver.ProductClient.CreateProduct(ctx, productclient.ToProtoProduct(product))
	if err != nil {
		log.Printf("Error creating product: %v", err)
		return "", fmt.Errorf("failed to create product: %w", err)
	}
	return "Product created successfully", nil
}

// UpdateProduct is the resolver for the updateProduct mutation.
func (r *mutationResolver) UpdateProduct(ctx context.Context, id string, input model.ProductInput) (string, error) {
	product := &model.Product{
		Title:       input.Title,
		Description: input.Description,
		Price:       input.Price,
		Stock:       input.Stock,
		Category:    input.Category,
		Attributes: &model.ProductAttributes{
			Color: input.Attributes.Color,
			Size:  input.Attributes.Size,
		},
		Images:    input.Images,
		Ratings:   input.Ratings,
	}
	err := r.Resolver.ProductClient.UpdateProduct(ctx, id, productclient.ToProtoProduct(product))
	if err != nil {
		log.Printf("Error updating product: %v", err)
		return "", fmt.Errorf("failed to update product: %w", err)
	}
	return "Product updated successfully", nil
}

// DeleteProduct is the resolver for the deleteProduct mutation.
func (r *mutationResolver) DeleteProduct(ctx context.Context, id string) (string, error) {
	err := r.Resolver.ProductClient.DeleteProduct(ctx, id)
	if err != nil {
		log.Printf("Error deleting product: %v", err)
		return "", fmt.Errorf("failed to delete product: %w", err)
	}
	return "Product deleted successfully", nil
}

// UpdateStock is the resolver for the updateStock mutation.
func (r *mutationResolver) UpdateStock(ctx context.Context, id string, quantity int32) (string, error) {
	err := r.Resolver.ProductClient.UpdateStock(ctx, id, quantity)
	if err != nil {
		log.Printf("Error updating stock: %v", err)
		return "", fmt.Errorf("failed to update stock: %w", err)
	}
	return "Stock updated successfully", nil
}

// GetUser is the resolver for the getUser query.
func (r *queryResolver) GetUser(ctx context.Context, username string) (*model.User, error) {
	resp, err := r.Resolver.UserClient.GetUser(ctx, username)
	if err != nil {
		log.Printf("Error fetching user: %v", err)
		return nil, fmt.Errorf("failed to fetch user: %w", err)
	}
	return &model.User{
		ID:       &resp.User.Id,
		Name:     &resp.User.Name,
		Email:    &resp.User.Email,
		Password: &resp.User.Password,
		Role:     &resp.User.Role,
	}, nil
}

// GetAllUsers is the resolver for the getAllUsers query.
func (r *queryResolver) GetAllUsers(ctx context.Context) ([]*model.User, error) {
	resp, err := r.Resolver.UserClient.GetAllUsers(ctx)
	if err != nil {
		log.Printf("Error fetching all users: %v", err)
		return nil, fmt.Errorf("failed to fetch all users: %w", err)
	}
	var users []*model.User
	for _, u := range resp.Users {
		users = append(users, &model.User{
			ID:       &u.Id,
			Name:     &u.Name,
			Email:    &u.Email,
			Password: &u.Password,
			Role:     &u.Role,
		})
	}
	return users, nil
}

// GetProductByID is the resolver for the getProductByID query.
func (r *queryResolver) GetProductByID(ctx context.Context, id string) (*model.Product, error) {
	protoProduct, err := r.Resolver.ProductClient.GetProductByID(ctx, id)
	if err != nil {
		log.Printf("Error fetching product by ID: %v", err)
		return nil, fmt.Errorf("failed to fetch product: %w", err)
	}
	return productclient.FromProtoProduct(protoProduct), nil
}

// GetAllProducts is the resolver for the getAllProducts query.
func (r *queryResolver) GetAllProducts(ctx context.Context, filters []*model.FilterInput) ([]*model.Product, error) {
	filterMap := make(map[string]string)
	for _, filter := range filters {
		filterMap[filter.Key] = filter.Value
	}
	protoProducts, err := r.Resolver.ProductClient.GetAllProducts(ctx, filterMap)
	if err != nil {
		log.Printf("Error fetching all products: %v", err)
		return nil, fmt.Errorf("failed to fetch all products: %w", err)
	}
	var products []*model.Product
	for _, protoProduct := range protoProducts {
		products = append(products, productclient.FromProtoProduct(protoProduct))
	}
	return products, nil
}

// GetProductsByCategory is the resolver for the getProductsByCategory query.
func (r *queryResolver) GetProductsByCategory(ctx context.Context, category string) ([]*model.Product, error) {
	protoProducts, err := r.Resolver.ProductClient.GetProductsByCategory(ctx, category)
	if err != nil {
		log.Printf("Error fetching products by category: %v", err)
		return nil, fmt.Errorf("failed to fetch products by category: %w", err)
	}
	var products []*model.Product
	for _, protoProduct := range protoProducts {
		products = append(products, productclient.FromProtoProduct(protoProduct))
	}
	return products, nil
}

// SearchProducts is the resolver for the searchProducts query.
func (r *queryResolver) SearchProducts(ctx context.Context, query string) ([]*model.Product, error) {
	protoProducts, err := r.Resolver.ProductClient.SearchProducts(ctx, query)
	if err != nil {
		log.Printf("Error searching products: %v", err)
		return nil, fmt.Errorf("failed to search products: %w", err)
	}
	var products []*model.Product
	for _, protoProduct := range protoProducts {
		products = append(products, productclient.FromProtoProduct(protoProduct))
	}
	return products, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
